# 챗봇 구조 비교 분석

## 정우코팅 현재 챗봇 vs Google NotebookLM 챗봇

---

## 📊 구조 비교 개요

| 항목 | 정우코팅 챗봇 | Google NotebookLM |
|------|--------------|-------------------|
| **플랫폼** | 자체 개발 (Next.js) | Google 서비스 |
| **AI 엔진** | OpenAI API (GPT-3.5/GPT-4) | Google Gemini |
| **데이터 저장** | Supabase (PostgreSQL) | Google Cloud |
| **프롬프트 관리** | DB 기반 (관리자 페이지) | NotebookLM 웹 인터페이스 |
| **커스터마이징** | 완전한 커스터마이징 가능 | 제한적 |
| **비용** | OpenAI API 사용료 | Google 서비스 비용 |

---

## 🏗️ 정우코팅 챗봇 구조

### 1. **프론트엔드 구조**

#### 컴포넌트: `components/Chatbot.tsx`
```typescript
- React 클라이언트 컴포넌트
- 상태 관리: useState, useRef
- 주요 기능:
  * 대화 메시지 관리
  * 빠른 질문 버튼 (카테고리별)
  * 대화 기록 불러오기
  * 세션 토큰 관리 (localStorage)
  * 실시간 스크롤
```

**주요 특징:**
- ✅ **빠른 질문 버튼**: 서비스 안내, 견적 문의, 작업 프로세스 등 카테고리별 버튼 제공
- ✅ **대화 기록 저장**: Supabase에 모든 대화 저장
- ✅ **세션 관리**: 브라우저별 세션 토큰으로 대화 기록 유지
- ✅ **커스텀 UI**: 정우코팅 브랜드에 맞춘 디자인

### 2. **백엔드 구조**

#### API 라우트: `app/api/chatbot/send/route.ts`
```typescript
POST /api/chatbot/send
- 메시지 수신 및 처리
- 지식베이스 검색 (Supabase)
- OpenAI API 호출
- 대화 기록 저장
- 토큰 사용량 및 비용 추적
```

**처리 흐름:**
1. 사용자 메시지 수신
2. 지식베이스 검색 (견적 문의가 아닌 경우)
3. 대화 기록 조회 (컨텍스트 유지)
4. DB 프롬프트 가져오기
5. OpenAI API로 응답 생성
6. 응답 저장 및 반환

#### 프롬프트 관리: `lib/openai.ts`
```typescript
- getQuotePrompt(): DB에서 프롬프트 가져오기
- generateChatbotResponse(): OpenAI API 호출
- generateQuoteResponse(): 프롬프트 기반 답변 생성
- 토큰 사용량 및 비용 계산
```

### 3. **데이터베이스 구조**

#### Supabase 테이블:
- `chatbot_sessions`: 세션 관리
- `chatbot_messages`: 대화 메시지 저장
- `chatbot_settings`: 프롬프트 저장 (quote_prompt)
- `chatbot_knowledge_base`: 지식베이스 (FAQ 등)
- `companies`: 회사 정보

### 4. **프롬프트 관리 시스템**

#### 관리자 페이지: `app/admin/chatbot-prompt/page.tsx`
- ✅ **DB 기반 프롬프트 관리**
- ✅ **실시간 편집 및 저장**
- ✅ **전체 프롬프트 통합 관리**
- ✅ **수정 모드 토글**

**프롬프트 구조:**
```
- 회사 정보
- 견적 산정 기준
- 서비스 상세 안내
- 연락처 안내
- 파일 제출 방법
- 작업 프로세스 및 납기일
- 기술적 전문 지식
```

---

## 📚 Google NotebookLM 챗봇 구조

### 1. **기본 구조**

#### 플랫폼:
- Google의 AI 노트북 서비스
- Gemini AI 모델 사용
- 문서 기반 학습

#### 주요 기능:
- ✅ **문서 업로드**: PDF, Google Docs, 웹페이지 등
- ✅ **자동 요약**: 업로드한 문서 자동 분석
- ✅ **대화형 인터페이스**: 문서 내용 기반 질문/답변
- ✅ **소스 인용**: 답변에 출처 표시

### 2. **데이터 관리**

#### 저장소:
- Google Cloud Storage
- 사용자 Google 계정과 연동
- 노트북별로 문서 관리

#### 프롬프트 관리:
- 웹 인터페이스에서 관리
- 문서 기반 학습 (명시적 프롬프트 없음)
- 문서 내용이 프롬프트 역할

### 3. **통합 방법**

#### 옵션 1: iframe 임베드
```html
<iframe src="https://notebooklm.google.com/your-notebook-url"></iframe>
```
- 장점: 간단한 통합
- 단점: 제한적인 커스터마이징

#### 옵션 2: API 연동 (제한적)
- NotebookLM은 공개 API를 제공하지 않음
- 공유 링크를 통한 접근만 가능

#### 옵션 3: 하이브리드
- 현재 챗봇과 NotebookLM 챗봇 선택 제공
- 사용자가 원하는 챗봇 선택

---

## 🔍 상세 비교

### 1. **프롬프트 관리**

| 항목 | 정우코팅 챗봇 | NotebookLM |
|------|--------------|------------|
| **관리 방식** | DB 기반, 관리자 페이지에서 직접 편집 | 문서 업로드, 웹 인터페이스 |
| **프롬프트 구조** | 구조화된 텍스트 프롬프트 | 문서 내용 자동 분석 |
| **업데이트** | 실시간 DB 업데이트 | 문서 재업로드 필요 |
| **버전 관리** | DB에 저장 (updated_at) | 노트북 버전 관리 |
| **커스터마이징** | 완전한 제어 | 문서 내용에 의존 |

### 2. **AI 엔진**

| 항목 | 정우코팅 챗봇 | NotebookLM |
|------|--------------|------------|
| **모델** | OpenAI GPT-3.5/GPT-4 | Google Gemini |
| **비용** | API 사용량 기반 | Google 서비스 비용 |
| **커스터마이징** | 프롬프트 완전 제어 | 문서 기반 학습 |
| **성능** | 높은 커스터마이징 가능 | 문서 이해도 우수 |

### 3. **데이터 저장**

| 항목 | 정우코팅 챗봇 | NotebookLM |
|------|--------------|------------|
| **대화 기록** | Supabase (자체 DB) | Google Cloud |
| **세션 관리** | 브라우저 localStorage | Google 계정 |
| **데이터 소유권** | 완전한 소유권 | Google 서비스 |
| **데이터 분석** | 자체 분석 가능 | Google Analytics 연동 |

### 4. **UI/UX**

| 항목 | 정우코팅 챗봇 | NotebookLM |
|------|--------------|------------|
| **디자인** | 완전한 커스터마이징 | Google 기본 UI |
| **빠른 질문 버튼** | ✅ 카테고리별 버튼 | ❌ 없음 |
| **대화 기록** | ✅ 자동 저장 및 불러오기 | ✅ Google 계정 연동 |
| **반응형** | ✅ 모바일 최적화 | ✅ Google 기본 반응형 |

### 5. **기능 비교**

#### 정우코팅 챗봇의 고유 기능:
- ✅ **빠른 질문 버튼**: 서비스, 견적, 프로세스 등 카테고리별
- ✅ **견적 문의 특화**: 견적 계산 로직 내장
- ✅ **지식베이스 통합**: Supabase 기반 FAQ 검색
- ✅ **대화 기록 관리**: 페이지별 세션 관리
- ✅ **피드백 시스템**: 답변 품질 피드백 수집
- ✅ **토큰 사용량 추적**: 비용 모니터링

#### NotebookLM의 고유 기능:
- ✅ **문서 기반 학습**: PDF, Docs 등 문서 업로드
- ✅ **소스 인용**: 답변에 출처 표시
- ✅ **자동 요약**: 문서 내용 자동 분석
- ✅ **다중 문서 관리**: 여러 문서를 하나의 노트북에서 관리
- ✅ **Google 통합**: Google Workspace와 연동

---

## 💡 통합 시나리오

### 시나리오 1: 완전 교체
**NotebookLM으로 완전 교체**
- 장점: 문서 기반 학습으로 관리 간편
- 단점: 빠른 질문 버튼, 견적 특화 기능 손실

### 시나리오 2: 병행 사용
**두 챗봇 모두 제공**
- 장점: 사용자 선택권 제공
- 단점: UI 복잡도 증가

### 시나리오 3: 하이브리드
**현재 챗봇 + NotebookLM 문서 참조**
- NotebookLM에서 문서 업로드
- 현재 챗봇이 NotebookLM API로 문서 내용 참조
- **제한**: NotebookLM 공개 API 없음

### 시나리오 4: 문서 기반 개선
**현재 챗봇에 NotebookLM 스타일 기능 추가**
- 문서 업로드 기능 추가
- 문서 기반 답변 생성
- 소스 인용 기능 추가

---

## 🎯 권장 사항

### 현재 챗봇 유지 + 개선
**이유:**
1. ✅ **완전한 커스터마이징**: 빠른 질문 버튼, 견적 특화 기능
2. ✅ **데이터 소유권**: 모든 대화 기록을 자체 DB에 저장
3. ✅ **프롬프트 제어**: 관리자 페이지에서 실시간 수정
4. ✅ **비용 투명성**: OpenAI API 사용량 기반 비용 관리

### NotebookLM 활용 방안
1. **내부 문서 관리**: 회사 문서를 NotebookLM에 업로드하여 관리
2. **프롬프트 작성 보조**: NotebookLM으로 문서 분석 후 프롬프트 작성에 활용
3. **고급 질문 처리**: 복잡한 문서 기반 질문은 NotebookLM 링크 제공

---

## 📝 결론

### 정우코팅 챗봇의 강점:
- ✅ 견적 문의 특화 기능
- ✅ 빠른 질문 버튼으로 사용자 편의성
- ✅ 완전한 커스터마이징
- ✅ 데이터 소유권 및 분석 가능

### NotebookLM의 강점:
- ✅ 문서 기반 자동 학습
- ✅ 소스 인용 기능
- ✅ Google 서비스 통합
- ✅ 문서 관리 편의성

### 최종 권장:
**현재 챗봇 구조를 유지하되, NotebookLM은 보조 도구로 활용**
- 주요 챗봇: 현재 챗봇 (견적, 빠른 질문 등)
- 보조 도구: NotebookLM (복잡한 문서 기반 질문)

---

## 🔧 기술적 세부사항

### 정우코팅 챗봇 아키텍처:
```
[사용자] 
  ↓
[Chatbot.tsx] (프론트엔드)
  ↓
[/api/chatbot/send] (Next.js API Route)
  ↓
[lib/openai.ts] (OpenAI API 호출)
  ↓
[Supabase] (프롬프트 및 대화 기록)
  ↓
[OpenAI API] (GPT 응답 생성)
```

### NotebookLM 아키텍처:
```
[사용자]
  ↓
[NotebookLM 웹 인터페이스]
  ↓
[Google Gemini API]
  ↓
[Google Cloud Storage] (문서 저장)
```

---

## 📌 참고사항

1. **NotebookLM 공개 API**: 현재 공개 API를 제공하지 않아 직접 통합 어려움
2. **iframe 임베드**: 공유 링크를 통한 iframe 임베드만 가능
3. **데이터 동기화**: 두 챗봇 간 데이터 동기화 불가능
4. **비용**: NotebookLM은 Google 서비스 비용, 현재 챗봇은 OpenAI API 비용

